"""
Base Strategy Class
All trading strategies inherit from this base
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional
from enum import Enum

from loguru import logger


class SignalType(Enum):
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE = "CLOSE"


class StrategyStatus(Enum):
    IDLE = "idle"
    SCANNING = "scanning"
    EXECUTING = "executing"
    PAUSED = "paused"
    ERROR = "error"


@dataclass
class TradeSignal:
    """Trading signal generated by strategy"""
    strategy_name: str
    signal_type: SignalType
    market_id: str
    token_id: str
    side: str  # YES or NO
    price: float
    size: float
    confidence: float  # 0-1
    expected_profit_pct: float
    reason: str
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def is_actionable(self) -> bool:
        """Check if signal should be acted upon"""
        return self.signal_type in [SignalType.BUY, SignalType.SELL] and self.confidence > 0.5


@dataclass
class StrategyResult:
    """Result of strategy execution"""
    strategy_name: str
    success: bool
    profit_loss: float
    trades_executed: int
    signals_generated: int
    duration_seconds: float
    timestamp: datetime = field(default_factory=datetime.now)
    errors: List[str] = field(default_factory=list)
    details: Dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategyMetrics:
    """Performance metrics for a strategy"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_profit: float = 0.0
    total_loss: float = 0.0
    largest_win: float = 0.0
    largest_loss: float = 0.0
    avg_trade_duration: float = 0.0
    sharpe_ratio: float = 0.0

    @property
    def win_rate(self) -> float:
        if self.total_trades == 0:
            return 0
        return self.winning_trades / self.total_trades

    @property
    def profit_factor(self) -> float:
        if self.total_loss == 0:
            return float('inf') if self.total_profit > 0 else 0
        return abs(self.total_profit / self.total_loss)

    @property
    def net_profit(self) -> float:
        return self.total_profit + self.total_loss  # loss is negative


class StrategyBase(ABC):
    """
    Abstract base class for all trading strategies
    """

    def __init__(
        self,
        name: str,
        config: Dict[str, Any],
        dry_run: bool = True
    ):
        self.name = name
        self.config = config
        self.dry_run = dry_run
        self.status = StrategyStatus.IDLE
        self._enabled = config.get('enabled', True)
        self._metrics = StrategyMetrics()
        self._active_signals: List[TradeSignal] = []
        self._trade_history: List[Dict] = []

    @property
    def enabled(self) -> bool:
        return self._enabled

    @enabled.setter
    def enabled(self, value: bool):
        self._enabled = value
        logger.info(f"Strategy {self.name} {'enabled' if value else 'disabled'}")

    @property
    def metrics(self) -> StrategyMetrics:
        return self._metrics

    @abstractmethod
    async def scan(self) -> List[TradeSignal]:
        """
        Scan markets for opportunities

        Returns:
            List of trade signals
        """
        pass

    @abstractmethod
    async def execute(self, signal: TradeSignal) -> StrategyResult:
        """
        Execute a trade signal

        Args:
            signal: Trade signal to execute

        Returns:
            StrategyResult with execution details
        """
        pass

    @abstractmethod
    async def close_position(self, market_id: str) -> StrategyResult:
        """
        Close an existing position

        Args:
            market_id: Market to close position in

        Returns:
            StrategyResult with closure details
        """
        pass

    async def run_once(self) -> StrategyResult:
        """
        Run one iteration of the strategy

        Returns:
            StrategyResult with iteration details
        """
        if not self.enabled:
            return StrategyResult(
                strategy_name=self.name,
                success=False,
                profit_loss=0,
                trades_executed=0,
                signals_generated=0,
                duration_seconds=0,
                errors=["Strategy is disabled"]
            )

        start_time = datetime.now()
        self.status = StrategyStatus.SCANNING

        try:
            # Scan for signals
            signals = await self.scan()
            self._active_signals = signals

            logger.info(f"[{self.name}] Generated {len(signals)} signals")

            # Execute actionable signals
            trades_executed = 0
            total_profit = 0.0
            errors = []

            self.status = StrategyStatus.EXECUTING

            for signal in signals:
                if signal.is_actionable:
                    result = await self.execute(signal)
                    if result.success:
                        trades_executed += result.trades_executed
                        total_profit += result.profit_loss
                    else:
                        errors.extend(result.errors)

            duration = (datetime.now() - start_time).total_seconds()
            self.status = StrategyStatus.IDLE

            return StrategyResult(
                strategy_name=self.name,
                success=True,
                profit_loss=total_profit,
                trades_executed=trades_executed,
                signals_generated=len(signals),
                duration_seconds=duration,
                errors=errors
            )

        except Exception as e:
            self.status = StrategyStatus.ERROR
            logger.error(f"[{self.name}] Error: {e}")
            return StrategyResult(
                strategy_name=self.name,
                success=False,
                profit_loss=0,
                trades_executed=0,
                signals_generated=0,
                duration_seconds=(datetime.now() - start_time).total_seconds(),
                errors=[str(e)]
            )

    def update_metrics(self, trade_result: Dict):
        """Update strategy metrics after a trade"""
        pnl = trade_result.get('profit_loss', 0)

        self._metrics.total_trades += 1

        if pnl > 0:
            self._metrics.winning_trades += 1
            self._metrics.total_profit += pnl
            self._metrics.largest_win = max(self._metrics.largest_win, pnl)
        elif pnl < 0:
            self._metrics.losing_trades += 1
            self._metrics.total_loss += pnl
            self._metrics.largest_loss = min(self._metrics.largest_loss, pnl)

        self._trade_history.append({
            **trade_result,
            'timestamp': datetime.now()
        })

    def get_status(self) -> Dict:
        """Get current strategy status"""
        return {
            'name': self.name,
            'enabled': self.enabled,
            'status': self.status.value,
            'active_signals': len(self._active_signals),
            'metrics': {
                'total_trades': self._metrics.total_trades,
                'win_rate': f"{self._metrics.win_rate:.1%}",
                'net_profit': self._metrics.net_profit,
                'profit_factor': self._metrics.profit_factor
            }
        }

    def calculate_position_size(
        self,
        bankroll: float,
        confidence: float,
        max_position_pct: float = 0.1
    ) -> float:
        """
        Calculate position size based on Kelly Criterion variant

        Args:
            bankroll: Total available capital
            confidence: Signal confidence (0-1)
            max_position_pct: Maximum position as % of bankroll

        Returns:
            Recommended position size in USD
        """
        # Modified Kelly: fraction = confidence - (1-confidence)/1
        # Capped at max_position_pct
        kelly_fraction = max(0, 2 * confidence - 1)
        position_pct = min(kelly_fraction, max_position_pct)

        return bankroll * position_pct

    def validate_signal(self, signal: TradeSignal) -> bool:
        """
        Validate a trade signal before execution

        Args:
            signal: Signal to validate

        Returns:
            True if signal is valid
        """
        # Basic validation
        if signal.size <= 0:
            logger.warning(f"Invalid signal: size <= 0")
            return False

        if signal.price <= 0 or signal.price >= 1:
            logger.warning(f"Invalid signal: price out of range")
            return False

        if signal.confidence < 0 or signal.confidence > 1:
            logger.warning(f"Invalid signal: confidence out of range")
            return False

        return True
